import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import { getSessionById, markSessionCompleted } from '../services/sessionService';
import FallbackMeeting from '../components/FallbackMeeting';
import { AIProvider } from '../contexts/AIContext';
import AIToolsContainer from '../components/AIComponents';
import ConstellationField from '../components/ConstellationField/index.jsx';
import ConstellationField3D from '../components/ConstellationField3D/index.jsx';
import { setupConstellationSync } from '../constellation-sync';
import '../styles/SessionRoom.css';

// Refer√™ncia global para controlar sess√µes e sincroniza√ß√µes
const globalSyncStates = {
  initializedSessions: new Set(),
  activeFields: new Map()
};

// Sistema de debug para monitorar ciclo de vida de componentes
const setupDebugMonitoring = () => {
  console.log('üîç Inicializando sistema de monitoramento de ciclo de vida');
  
  // Registrar momentos de montagem/desmontagem
  window.componentLifecycles = window.componentLifecycles || {};
  
  // Registrar montagem de componente
  window.registerMount = (componentId) => {
    const timestamp = Date.now();
    window.componentLifecycles[componentId] = {
      mounted: timestamp,
      mountCount: (window.componentLifecycles[componentId]?.mountCount || 0) + 1
    };
    console.log(`üü¢ Componente ${componentId} montado [#${window.componentLifecycles[componentId].mountCount}] em ${new Date(timestamp).toISOString()}`);
  };
  
  // Registrar desmontagem de componente
  window.registerUnmount = (componentId) => {
    const timestamp = Date.now();
    if (window.componentLifecycles[componentId]) {
      window.componentLifecycles[componentId].unmounted = timestamp;
      window.componentLifecycles[componentId].lastLifetime = 
        timestamp - window.componentLifecycles[componentId].mounted;
      
      console.log(`üî¥ Componente ${componentId} desmontado ap√≥s ${window.componentLifecycles[componentId].lastLifetime}ms`);
    } else {
      console.log(`üî¥ Componente ${componentId} desmontado (sem registro de montagem)`);
    }
  };
  
  // Fun√ß√£o para verificar estabilidade dos componentes
  window.checkStability = () => {
    console.log('üìä Verificando estabilidade dos componentes:');
    Object.entries(window.componentLifecycles).forEach(([id, data]) => {
      console.log(`${id}: ${data.mountCount} montagens, √∫ltima dura√ß√£o: ${data.lastLifetime || 'ainda ativo'}ms`);
    });
  };
  
  // Configurar verifica√ß√£o peri√≥dica
  window.stabilityInterval = setInterval(window.checkStability, 10000);
  
  // Adicionar ao objeto window para debugging via console
  window.debugComponents = {
    getLifecycles: () => window.componentLifecycles,
    clearMonitoring: () => {
      clearInterval(window.stabilityInterval);
      window.componentLifecycles = {};
      console.log('üßπ Monitoramento de componentes limpo');
    }
  };
  
  return () => {
    // Fun√ß√£o de limpeza
    clearInterval(window.stabilityInterval);
    window.componentLifecycles = {};
  };
};

const SessionRoom = () => {
  const { sessionId } = useParams();
  const navigate = useNavigate();
  
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isPipMode, setIsPipMode] = useState(false);
  const [fullScreenElement, setFullScreenElement] = useState(null);
  const [showControls, setShowControls] = useState(true);
  const [videoPosition, setVideoPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [isRoomMounted, setIsRoomMounted] = useState(false);
  const [showAITools, setShowAITools] = useState(true);
  const [showConstellation, setShowConstellation] = useState(false);
  const [userRole, setUserRole] = useState(null);
  const [videoDimensions, setVideoDimensions] = useState({ width: 300, height: 200 });
  const [isResizing, setIsResizing] = useState(false);
  const [isFullScreen, setIsFullScreen] = useState(false);
  
  const aiContainerRef = useRef(null);
  const videoContainerRef = useRef(null);
  const constellationContainerRef = useRef(null);
  const dailyCallRef = useRef(null);
  
  // Refer√™ncia para o FallbackMeeting - evitar remontagens
  const fallbackMeetingRef = useRef(null);
  
  // Refer√™ncias para elementos importantes
  const videoModeRef = useRef({
    isPip: false,
    lastChange: 0,
    skipNextChange: false,
    changedByVideo: false,
    lastFloatingValue: false,
    lastDomUpdate: 0
  });
  
  // Dentro do componente, adicionar estado para armazenar a refer√™ncia de sync
  const [sync, setSync] = useState(null);
  
  // Criar refer√™ncia para setupDailyMessageHandlers
  const setupDailyMessageHandlersRef = useRef(null);

  // Verificar se o container de AI est√° vazio ap√≥s a montagem
  useEffect(() => {
    const checkIfAIContainerEmpty = () => {
      if (aiContainerRef.current) {
        const hasContent = aiContainerRef.current.querySelector('.persistent-ai-tools');
        if (!hasContent || (hasContent && !hasContent.childNodes.length)) {
          setShowAITools(false);
        } else {
          setShowAITools(true);
        }
      }
    };
    
    // Verificar inicialmente
    checkIfAIContainerEmpty();
    
    // Configurar um MutationObserver para monitorar mudan√ßas no container
    const observer = new MutationObserver(checkIfAIContainerEmpty);
    
    if (aiContainerRef.current) {
      observer.observe(aiContainerRef.current, { 
        childList: true, 
        subtree: true 
      });
    }
    
    // Verificar novamente ap√≥s alguns segundos para garantir
    const timer = setTimeout(checkIfAIContainerEmpty, 3000);
    
    return () => {
      observer.disconnect();
      clearTimeout(timer);
    };
  }, [isRoomMounted]);

  // Carregar dados da sess√£o
  useEffect(() => {
    const fetchSessionData = async () => {
      try {
        setLoading(true);
        const data = await getSessionById(sessionId);
        setSession(data);
        
        console.log('Dados da sess√£o carregados:', data);
        
        // Verificar o papel do usu√°rio atual
        const authToken = sessionStorage.getItem('authToken') || localStorage.getItem('authToken');
        if (authToken) {
          try {
            // Decodificar o token JWT para obter o ID do usu√°rio
            const decodedToken = JSON.parse(atob(authToken.split('.')[1]));
            const currentUserId = decodedToken.id || decodedToken.userId;
            
            console.log('ID do usu√°rio atual:', currentUserId);
            console.log('ID do terapeuta da sess√£o:', data.therapistId);
            
            // Verificar a estrutura dos dados da sess√£o
            if (data.therapist && data.therapist.userId) {
              console.log('ID do usu√°rio terapeuta na sess√£o:', data.therapist.userId);
              
              // Se o usu√°rio atual √© o terapeuta da sess√£o (pelo userId do objeto therapist)
              if (data.therapist.userId === currentUserId) {
                console.log('Usu√°rio √© o terapeuta que est√° oferecendo o servi√ßo');
                setUserRole('therapist-provider');
              } else {
                console.log('Usu√°rio n√£o √© o terapeuta da sess√£o');
                setUserRole('client');
              }
            } 
            // Se n√£o tiver a estrutura esperada, usar o therapistId direto
            else if (data.therapistId) {
              // Se o usu√°rio atual √© o terapeuta da sess√£o (pelo therapistId)
              if (data.therapistId === currentUserId) {
                console.log('Usu√°rio √© o terapeuta que est√° oferecendo o servi√ßo (pelo therapistId)');
                setUserRole('therapist-provider');
              } else {
                console.log('Usu√°rio n√£o √© o terapeuta da sess√£o (pelo therapistId)');
                setUserRole('client');
              }
            } 
            // √öltimo recurso, verificar o role no token
            else {
              const userRole = decodedToken.role;
              console.log('Role no token:', userRole);
              
              if (userRole === 'THERAPIST' || userRole === 'therapist') {
                console.log('Usu√°rio √© terapeuta (pelo token)');
                setUserRole('therapist-provider');
              } else {
                console.log('Usu√°rio n√£o √© terapeuta (pelo token)');
                setUserRole('client');
              }
            }
          } catch (error) {
            console.error('Erro ao decodificar token:', error);
            // Em caso de erro, definir como terapeuta para n√£o bloquear funcionalidades
            console.log('Erro ao verificar papel - assumindo terapeuta por seguran√ßa');
            setUserRole('therapist-provider');
          }
        } else {
          console.log('Nenhum token de autentica√ß√£o encontrado');
        }
        
        document.title = `${data.title || 'Sess√£o'} - TerapiaConect`;
        setError(null);
      } catch (err) {
        console.error('Erro ao carregar sess√£o:', err);
        // Em vez de apenas mostrar erro, criar uma sess√£o tempor√°ria para permitir a videochamada
        setSession({
          id: sessionId,
          title: 'Sess√£o Terap√™utica',
          therapist: { name: 'Terapeuta' },
          isTemporary: true
        });
        setError('Usando modo tempor√°rio de videochamada');
        toast.warning('Usando modo tempor√°rio de videochamada');
        
        // Em caso de erro, permitir acesso √†s ferramentas por padr√£o
        console.log('Erro ao carregar sess√£o - assumindo terapeuta por padr√£o');
        setUserRole('therapist-provider');
      } finally {
        setLoading(false);
      }
    };

    if (sessionId) {
      console.log(`Sess√£o inicializada com ID: ${sessionId}`);
      
      // Expor ID da sess√£o em vari√°vel global para facilitar acesso em outros componentes
      window.currentSessionData = {
        id: sessionId,
        timestamp: Date.now()
      };
      
      // Armazenar tamb√©m no sessionStorage
      sessionStorage.setItem('currentSessionId', sessionId);
      
      fetchSessionData();
    }
    
    // Limpar ao desmontar
    return () => {
      if (dailyCallRef.current) {
        try {
          dailyCallRef.current.destroy();
        } catch (error) {
          console.error('Erro ao destruir dailyCall:', error);
        }
      }
      
      // Limpar refer√™ncia global
      if (window.currentSessionData && window.currentSessionData.id === sessionId) {
        delete window.currentSessionData;
      }
      
      // Remover do sessionStorage se estiver saindo desta sess√£o
      if (sessionStorage.getItem('currentSessionId') === sessionId) {
        sessionStorage.removeItem('currentSessionId');
      }
    };
  }, [sessionId]);

  // Criar refer√™ncia para a fun√ß√£o sendUpdate no n√≠vel principal do componente
  const sendUpdateRef = useRef(null);

  // Fun√ß√£o para lidar com mensagens recebidas sobre o estado do campo
  const handleShowConstellation = useCallback((event) => {
    console.log('üì• Recebeu evento show-constellation:', event);
    
    // Validar evento
    if (!event || !event.detail || event.detail.sessionId !== sessionId) {
      console.log('Evento inv√°lido ou para outra sess√£o, ignorando');
      return;
    }
    
    // Verificar se vem de uma origem remota (outro participante)
    const isRemoteEvent = event.detail.remote === true || event.detail.source === 'daily-api' || event.detail.source === 'sync-system';
    
    console.log('Processando evento de ativa√ß√£o do campo', { isRemoteEvent, source: event.detail.source });
    
    // Se j√° estiver ativo, apenas garantir visibilidade sem mudar estado
    if (showConstellation) {
      console.log('Campo j√° est√° ativo, garantindo visibilidade');
      
      // Garantir visibilidade ap√≥s breve delay
      setTimeout(() => {
        // Garantir que o container de constela√ß√£o seja vis√≠vel
        const constellationContainer = document.querySelector('.constellation-container');
        if (constellationContainer) {
          constellationContainer.style.display = 'block';
          constellationContainer.style.opacity = '1';
          constellationContainer.style.visibility = 'visible';
        }
        
        // Garantir que o v√≠deo em modo PIP esteja vis√≠vel
        const pipContainer = document.querySelector('.video-container-pip');
        if (pipContainer) {
          pipContainer.style.display = 'block';
          pipContainer.style.visibility = 'visible';
          pipContainer.style.opacity = '1';
          pipContainer.style.zIndex = '999';
        }
      }, 300);
      
      return;
    }
    
    // Persistir estado no sessionStorage
    sessionStorage.setItem(`constellation-active-${sessionId}`, 'true');
    
    // Adicionar classe imediatamente para feedback visual
    const sessionRoomElement = document.querySelector('.session-room');
    if (sessionRoomElement) {
      sessionRoomElement.classList.add('with-constellation');
    }
    
    // IMPORTANTE: Primeiro acionar o modo PIP no componente de v√≠deo VIA REF
    // antes de qualquer mudan√ßa de estado React para evitar remontagem
    if (fallbackMeetingRef.current && fallbackMeetingRef.current.setFloating) {
      console.log('Definindo modo PIP via ref ANTES da mudan√ßa de estado para evento remoto');
      fallbackMeetingRef.current.setFloating(true);
    }
    
    // Verificar se devemos for√ßar modo PIP
    const forcePIP = event.detail.forcePIP === true;
    
    // Disparar evento para evitar recria√ß√£o do componente de v√≠deo (somente se n√£o for√ßar PIP)
    if (!forcePIP) {
      window.dispatchEvent(new CustomEvent('pre-constellation-change', {
        detail: {
          sessionId,
          timestamp: Date.now()
        }
      }));
    }
    
    // Atualizar o estado
    setShowConstellation(true);
    
    // Mostrar notifica√ß√£o apenas se solicitado por usu√°rio remoto e n√£o suprimido
    if (isRemoteEvent && !event.detail.suppressNotification) {
      toast.info('Campo de Constela√ß√£o ativado por outro participante', {
        position: "top-right",
        autoClose: 3000
      });
    }
    
    // Acionar evento de ativa√ß√£o para o componente do campo
    window.dispatchEvent(new CustomEvent('activate-constellation', {
      detail: {
        sessionId,
        timestamp: Date.now(),
        suppressNotification: true
      }
    }));
  }, [sessionId, showConstellation, fallbackMeetingRef]);

  // Setup constellation synchronization
  useEffect(() => {
    // Verificar se a inicializa√ß√£o j√° foi feita (para evitar inicializa√ß√£o m√∫ltipla)
    const syncInitKey = `sync-initialized-${sessionId}`;
    if (sessionStorage.getItem(syncInitKey) === 'true') {
      console.log('Sistema de sincroniza√ß√£o j√° inicializado para esta sess√£o');
      return;
    }
    
    console.log('Configurando sistema de sincroniza√ß√£o para o campo de constela√ß√£o');
    
    // Instalar logger global para eventos relacionados √† constela√ß√£o
    const originalAddEventListener = window.addEventListener;
    const originalDispatchEvent = window.dispatchEvent;
    
    // Interceptar addEventListener para logar
    window.addEventListener = function(type, listener, options) {
      // Verificar se √© um evento relacionado √† constela√ß√£o
      if (type.includes('constellation')) {
        console.log(`[EventLogger] Registrando listener para evento: ${type}`);
      }
      
      // Chamar a fun√ß√£o original
      return originalAddEventListener.call(this, type, listener, options);
    };
    
    // Interceptar dispatchEvent para logar
    window.dispatchEvent = function(event) {
      // Verificar se √© um evento relacionado √† constela√ß√£o
      if (event.type && event.type.includes('constellation')) {
        console.log(`[EventLogger] Disparando evento: ${event.type}`, 
          event.detail ? {
            sessionId: event.detail.sessionId,
            timestamp: event.detail.timestamp,
            show: event.detail.show
          } : '(sem detalhes)');
      }
      
      // Chamar a fun√ß√£o original
      return originalDispatchEvent.call(this, event);
    };
    
    // Marcar como inicializado
    sessionStorage.setItem(syncInitKey, 'true');
    
    // Limpar qualquer estado persistente anterior para evitar problemas
    sessionStorage.removeItem('constellation-active');
    
    // For√ßar o estado para desativado inicialmente
    setShowConstellation(false);
    
    // Remover classe do DOM se existir (para garantir estado inicial limpo)
    const sessionRoomElement = document.querySelector('.session-room');
    if (sessionRoomElement) {
      sessionRoomElement.classList.remove('with-constellation');
    }
    
    // NOVO: Inicializar sistema de sincroniza√ß√£o
    const handleSyncStateChange = (newState, data) => {
      console.log('Recebido evento de sincroniza√ß√£o:', { newState, hasData: !!data });
      
      if (typeof newState === 'boolean') {
        // Se o estado mudou para ativo, isso indica uma ativa√ß√£o remota
        if (newState === true && !showConstellation) {
          // Simular um evento de ativa√ß√£o
          const showEvent = new CustomEvent('constellation-show', {
            detail: {
              sessionId,
              show: true,
              remote: true,
              timestamp: Date.now(),
              source: 'sync-system'
            }
          });
          window.dispatchEvent(showEvent);
        }
      }
    };
    
    const syncInstance = setupConstellationSync(sessionId, handleSyncStateChange);
    setSync(syncInstance);
    console.log('Sistema de sincroniza√ß√£o inicializado com sucesso');
    
    // Configurar listeners para os eventos de ativa√ß√£o
    window.addEventListener('constellation-show', handleShowConstellation);
    
    // Configurar listener para eventos da API de mensagens da Dailyco
    const handleDailyAppMessage = (event) => {
      try {
        if (!event || !event.data) return;
        
        console.log('Mensagem recebida da API Daily.co:', event.data);
        
        // Verificar se √© do tipo que nos interessa
        if (event.data.type === 'constellation-show' || 
            event.data.type === 'constellation-toggle') {
          
          // Validar se √© para esta sess√£o
          if (event.data.sessionId !== sessionId) {
            console.log('Mensagem para outra sess√£o, ignorando');
            return;
          }
          
          console.log('Recebida mensagem de ativa√ß√£o via Daily.co:', event.data);
          
          // Verificar se devemos ativar o campo
          if (event.data.show === true) {
            // Simular um evento de ativa√ß√£o
            const showEvent = new CustomEvent('constellation-show', {
              detail: {
                sessionId,
                show: true,
                remote: true,
                timestamp: Date.now(),
                source: 'daily-api',
                suppressNotification: false
              }
            });
            window.dispatchEvent(showEvent);
          }
        }
      } catch (error) {
        console.error('Erro ao processar mensagem Daily.co:', error);
      }
    };
    
    // Registrar para receber mensagens do Daily.co quando o objeto estiver dispon√≠vel
    const checkForDailyAndRegister = () => {
      if (dailyCallRef.current) {
        try {
          dailyCallRef.current.on('app-message', handleDailyAppMessage);
          console.log('Registrado para receber mensagens Daily.co');
        } catch (error) {
          console.error('Erro ao registrar para mensagens Daily.co:', error);
        }
      } else {
        console.log('Daily.co ainda n√£o dispon√≠vel, tentando novamente...');
        setTimeout(checkForDailyAndRegister, 1000);
      }
    };
    
    // Iniciar verifica√ß√£o
    checkForDailyAndRegister();
    
    // Limpeza ao desmontar
    return () => {
      // Restaurar as fun√ß√µes originais
      window.addEventListener = originalAddEventListener;
      window.dispatchEvent = originalDispatchEvent;
      
      // Desregistrar listeners
      window.removeEventListener('constellation-show', handleShowConstellation);
      
      // Limpar o sistema de sincroniza√ß√£o
      if (sync && typeof sync.cleanup === 'function') {
        sync.cleanup();
      }
      
      // Remover marca√ß√£o de inicializa√ß√£o
      sessionStorage.removeItem(syncInitKey);
      
      // Limpar o estado de ativa√ß√£o
      sessionStorage.removeItem('constellation-active');
      
      console.log('Sistema de sincroniza√ß√£o para o campo de constela√ß√£o foi desmontado');
    };
  }, [sessionId, handleShowConstellation, showConstellation]);

  // Monitorar mudan√ßas no estado de tela cheia
  useEffect(() => {
    const handleFullScreenChange = () => {
      const isDocFullScreen = document.fullscreenElement !== null || 
                              document.webkitFullscreenElement !== null ||
                              document.msFullscreenElement !== null;
      
      setIsFullScreen(isDocFullScreen);
      setFullScreenElement(document.fullscreenElement);
      
      // Mostrar controles por alguns segundos ao entrar/sair da tela cheia
      setShowControls(true);
      setTimeout(() => {
        if (!isPipMode) {
          setShowControls(false);
        }
      }, 3000);
    };

    document.addEventListener('fullscreenchange', handleFullScreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullScreenChange);
    document.addEventListener('msfullscreenchange', handleFullScreenChange);
    
    return () => {
      document.removeEventListener('fullscreenchange', handleFullScreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullScreenChange);
      document.removeEventListener('msfullscreenchange', handleFullScreenChange);
    };
  }, [isPipMode]);

  // Fun√ß√£o simplificada para iniciar o arrasto do v√≠deo
  const handleMouseDown = (e) => {
    // Interromper a propaga√ß√£o do evento para evitar que o clique afete outros elementos
    e.stopPropagation();
    e.preventDefault();
    
    // Se o clique foi no bot√£o para fechar ou em outro controle, n√£o iniciar arrasto
    if (e.target.closest('.exit-constellation-btn') || e.target.closest('.video-resizer')) {
      return;
    }
    
    // Posi√ß√£o inicial do mouse
    const startX = e.clientX;
    const startY = e.clientY;
    
    // Posi√ß√£o inicial do elemento
    const startLeft = videoPosition.x;
    const startTop = videoPosition.y;
    
    // Sinalizar que estamos arrastando
    setIsDragging(true);
    
    // Fun√ß√£o para mover o elemento
    function handleMove(moveEvent) {
      // Calcular o deslocamento
      const deltaX = moveEvent.clientX - startX;
      const deltaY = moveEvent.clientY - startY;
      
      // Atualizar a posi√ß√£o
      setVideoPosition({
        x: startLeft + deltaX,
        y: startTop + deltaY
      });
    }
    
    // Fun√ß√£o para encerrar o arrasto
    function handleUp() {
      // Remover os event listeners
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
      
      // Sinalizar que n√£o estamos mais arrastando
      setIsDragging(false);
    }
    
    // Adicionar event listeners para mover e soltar
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);
  };

  // Fun√ß√£o simplificada para redimensionar o v√≠deo
  const handleResizeStart = (e) => {
    e.stopPropagation();
    e.preventDefault();
    
    // Posi√ß√£o inicial do mouse
    const startX = e.clientX;
    const startY = e.clientY;
    
    // Dimens√µes iniciais
    const startWidth = videoDimensions.width;
    const startHeight = videoDimensions.height;
    
    // Sinalizar que estamos redimensionando
    setIsResizing(true);
    
    // Fun√ß√£o para redimensionar
    function handleMove(moveEvent) {
      // Calcular o deslocamento
      const deltaX = moveEvent.clientX - startX;
      const deltaY = moveEvent.clientY - startY;
      
      // Atualizar as dimens√µes
      setVideoDimensions({
        width: Math.max(200, startWidth + deltaX),
        height: Math.max(150, startHeight + deltaY)
      });
    }
    
    // Fun√ß√£o para encerrar o redimensionamento
    function handleUp() {
      // Remover os event listeners
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
      
      // Sinalizar que n√£o estamos mais redimensionando
      setIsResizing(false);
    }
    
    // Adicionar event listeners para mover e soltar
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);
  };

  // Fun√ß√£o para alternar o campo de constela√ß√£o
  const handleConstellationToggle = async () => {
    console.log('üîÑ Toggle Constellation - Estado atual:', showConstellation);
    
    // Verificar se j√° foi ativado recentemente para evitar m√∫ltiplos cliques
    const lastActivationTime = parseInt(sessionStorage.getItem(`constellation-last-activation-${sessionId}`)) || 0;
    const now = Date.now();
    
    if (now - lastActivationTime < 2000) {
      console.log('Ignorando clique duplo em menos de 2 segundos');
      return;
    }
    
    // Salvar o novo timestamp de ativa√ß√£o
    sessionStorage.setItem(`constellation-last-activation-${sessionId}`, now.toString());
    
    // Sempre for√ßar ativa√ß√£o - nunca desativar ao clicar no bot√£o
    const newState = true;
    
    // Verificar se o componente de v√≠deo existe e est√° montado antes de continuar
    if (!fallbackMeetingRef.current) {
      console.warn('Componente de v√≠deo n√£o est√° dispon√≠vel, aguardando montagem...');
      toast.warning('Aguardando inicializa√ß√£o do v√≠deo antes de ativar o campo');
      
      // Tentar novamente em 2 segundos
      setTimeout(() => handleConstellationToggle(), 2000);
      return;
    }
    
    console.log('Componente de v√≠deo est√° pronto, prosseguindo com ativa√ß√£o');
    
    // Mostrar mensagem de carregamento enquanto garantimos o Daily.co
    toast.info('Preparando campo de constela√ß√£o...', {
      position: "top-right",
      autoClose: 1500,
      hideProgressBar: true
    });
    
    // Usar o novo m√©todo para garantir que o objeto Daily.co esteja dispon√≠vel
    try {
      // Tentar obter a API via v√°rios m√©todos para garantir
      // 1. Verificar se j√° temos o objeto via dailyCallRef
      let dailyCall = dailyCallRef.current;
      
      // 2. Tentar obter do componente de v√≠deo
      if (!dailyCall && fallbackMeetingRef.current.getDailyCall) {
        dailyCall = fallbackMeetingRef.current.getDailyCall();
      }
      
      // 3. Se ainda n√£o tiver, usar o novo m√©todo para criar sob demanda
      if (!dailyCall && fallbackMeetingRef.current.ensureDailyCall) {
        console.log('Tentando criar objeto Daily.co sob demanda...');
        try {
          dailyCall = await fallbackMeetingRef.current.ensureDailyCall();
        } catch (createError) {
          console.error('Falha ao criar Daily.co sob demanda:', createError);
        }
      }
      
      // 4. Tentar objeto global como √∫ltimo recurso
      if (!dailyCall && window._dailyAPI) {
        console.log('Usando objeto global _dailyAPI como √∫ltimo recurso');
        dailyCall = window._dailyAPI;
      }
      
      if (!dailyCall) {
        console.error('Objeto Daily.co n√£o dispon√≠vel por nenhum m√©todo. Continuando sem sincroniza√ß√£o.');
        
        // Avisar o usu√°rio, mas continuar com ativa√ß√£o local
        toast.warning('Modo offline: outros participantes n√£o ver√£o o campo', {
          position: "top-right",
          autoClose: 3000
        });
      } else {
        console.log('Objeto Daily.co dispon√≠vel, enviando mensagem de sincroniza√ß√£o...');
        
        // Construir mensagem de sincroniza√ß√£o
        const message = {
          type: 'constellation-show',
          show: newState,
          sessionId,
          timestamp: now,
          clientId: `client_${Date.now()}`,
          forceUpdate: true,
          initiator: 'user',
          source: 'user-action'
        };
        
        // Tentar enviar mensagem
        try {
          // Usar diretamente a API do Daily.co para enviar a mensagem
          dailyCall.sendAppMessage(message, '*');
          console.log('Mensagem de ativa√ß√£o enviada via Daily.co para todos os participantes');
          
          // Tamb√©m disparar evento interno para outros subsistemas
          window.dispatchEvent(new CustomEvent('constellation-sync-event', { 
            detail: {
              ...message,
              localSync: true
            }
          }));
        } catch (syncError) {
          console.error('Erro ao enviar mensagem de sincroniza√ß√£o:', syncError);
          toast.error('Erro ao sincronizar: outros participantes podem n√£o ver o campo', {
            position: "top-right",
            autoClose: 3000
          });
        }
      }
      
      // IMPORTANTE: Primeiro acionar o modo PIP no componente de v√≠deo VIA REF
      // antes de qualquer mudan√ßa de estado React para evitar remontagem
      if (fallbackMeetingRef.current && fallbackMeetingRef.current.setFloating) {
        console.log('Definindo modo PIP via ref ANTES da mudan√ßa de estado');
        fallbackMeetingRef.current.setFloating(true);
      }
      
      // Adicionar classe imediatamente para feedback visual
      const sessionRoomElement = document.querySelector('.session-room');
      if (sessionRoomElement) {
        sessionRoomElement.classList.add('with-constellation');
      }
      
      // Mostrar notifica√ß√£o de sucesso
      toast.success('Campo de Constela√ß√£o ativado!', {
        position: "top-right",
        autoClose: 2000,
        hideProgressBar: false
      });
      
      // Persistir estado no sessionStorage
      sessionStorage.setItem(`constellation-active-${sessionId}`, 'true');
      
      // For√ßar visibilidade do campo e do v√≠deo PIP ap√≥s um breve delay
      setTimeout(() => {
        // Garantir que o container de constela√ß√£o seja vis√≠vel
        const constellationContainer = document.querySelector('.constellation-container');
        if (constellationContainer) {
          constellationContainer.style.display = 'block';
          constellationContainer.style.opacity = '1';
          constellationContainer.style.visibility = 'visible';
        }
        
        // Garantir que o v√≠deo em modo PIP esteja vis√≠vel
        const pipContainer = document.querySelector('.video-container-pip');
        if (pipContainer) {
          pipContainer.style.display = 'block';
          pipContainer.style.visibility = 'visible';
          pipContainer.style.opacity = '1';
          pipContainer.style.zIndex = '9999';
        }
        
        console.log('For√ßando visibilidade dos elementos ap√≥s ativa√ß√£o');
      }, 300);
      
      // Apenas DEPOIS de configurar o modo PIP no componente, atualizar o estado React
      console.log('Atualizando estado React AP√ìS configura√ß√£o do modo PIP');
      setShowConstellation(newState);
      
      // Disparar eventos personalizados
      console.log('Disparando eventos de ativa√ß√£o');
      window.dispatchEvent(new CustomEvent('activate-constellation', {
        detail: {
          sessionId,
          timestamp: Date.now(),
          suppressNotification: true  // Evitar notifica√ß√£o duplicada
        }
      }));
      
      // For√ßar sincroniza√ß√£o com outros clientes usando sistema dedicado de sync
      if (typeof sync === 'object' && typeof sync.forceSyncNow === 'function') {
        try {
          sync.forceSyncNow(true, null, dailyCall);
          console.log('Solicita√ß√£o de forceSync enviada via sistema dedicado');
        } catch (error) {
          console.error('Erro ao for√ßar sincroniza√ß√£o via sistema dedicado:', error);
        }
      }
    } catch (error) {
      console.error('Erro ao ativar campo de constela√ß√£o:', error);
      
      // Ativar localmente mesmo com erro
      setShowConstellation(true);
      
      // Mostrar erro, mas n√£o bloquear a experi√™ncia
      toast.error('Erro na sincroniza√ß√£o. O campo foi ativado apenas para voc√™.', {
        position: "top-right",
        autoClose: 4000
      });
    }
  };

  // Alternar o modo PIP
  const handlePipModeChange = useCallback((enabled) => {
    console.log(`Modo PIP ${enabled ? 'ativado' : 'desativado'} pela videoconfer√™ncia`);
    
    // Marcar que esta altera√ß√£o foi iniciada pelo componente de v√≠deo
    videoModeRef.current.changedByVideo = true;
    videoModeRef.current.isPip = enabled;
    
    // Se o campo de constela√ß√£o estiver ativo, manter ativo
    // Apenas atualizamos o modo de exibi√ß√£o do v√≠deo sem alterar o estado
    if (showConstellation && !enabled) {
      console.log('Mantendo campo de constela√ß√£o ativo, apenas ajustando v√≠deo');
      
      // Atualizar modos de exibi√ß√£o diretamente no DOM sem re-renderizar
      const sessionRoomElement = document.querySelector('.session-room');
      if (sessionRoomElement) {
        if (enabled) {
          sessionRoomElement.classList.add('video-pip-mode');
        } else {
          sessionRoomElement.classList.remove('video-pip-mode');
        }
      }
    } else if (!showConstellation && enabled) {
      // Comportamento normal quando o campo n√£o est√° ativo e estamos ativando o PIP
      // Atualizar o estado (isso renderiza o componente)
      setShowConstellation(true);
    } else if (showConstellation && enabled) {
      // J√° est√° no modo que queremos, n√£o fazer nada
      console.log('J√° estamos no modo PIP, ignorando evento');
    } else if (!showConstellation && !enabled) {
      // J√° est√° no modo que queremos, n√£o fazer nada
      console.log('J√° estamos no modo normal, ignorando evento');
    }
    
    // Resetar o flag ap√≥s um pequeno delay
    setTimeout(() => {
      videoModeRef.current.changedByVideo = false;
    }, 200);
  }, [showConstellation]);

  // Definir a fun√ß√£o setupDailyMessageHandlers
  const setupDailyMessageHandlers = useCallback((dailyCallObj, clientId) => {
    if (!dailyCallObj) {
      console.error('Objeto Daily.co inv√°lido passado para setupDailyMessageHandlers');
      return;
    }

    try {
      console.log('Configurando listeners para mensagens...');
      
      // Remover qualquer listener existente para evitar duplica√ß√£o
      try {
        dailyCallObj.off('app-message');
        console.log('Removidos listeners anteriores');
      } catch (cleanupErr) {
        console.warn('Erro ao limpar listeners anteriores:', cleanupErr);
      }
      
      // Configurar novo listener para todas as mensagens do Daily.co
      dailyCallObj.on('app-message', (evt) => {
        const message = evt.data;
        
        // Log detalhado da mensagem recebida
        console.log('üì¨ Mensagem recebida via Daily.co:', {
          type: message?.type,
          sessionId: message?.sessionId,
          mySessionId: sessionId,
          timestamp: new Date().toISOString()
        });
        
        // Processar mensagens relacionadas √† constela√ß√£o
        if (message && (
            message.type === 'constellation-show' || 
            message.type === 'constellation-toggle' ||
            message.type === 'activate-constellation'
        )) {
          console.log('Mensagem de ativa√ß√£o de constela√ß√£o recebida:', message);
          
          // Evitar processamento de mensagens antigas
          const msgTime = message.timestamp || Date.now();
          const now = Date.now();
          if (now - msgTime > 10000) {
            console.log('Ignorando mensagem muito antiga (> 10s)');
            return;
          }
          
          // Verificar se a mensagem se aplica a esta sess√£o
          if (message.sessionId && message.sessionId !== sessionId) {
            console.log('Mensagem para outra sess√£o, ignorando');
            return;
          }
          
          // Se o campo de constela√ß√£o deve ser ativado
          if (message.show === true || message.type === 'activate-constellation') {
            console.log('Mensagem indica ativa√ß√£o do campo - disparando evento interno');
            
            // Criar evento interno para ativar o campo
            window.dispatchEvent(new CustomEvent('constellation-show', {
              detail: {
                sessionId,
                show: true,
                remote: true,
                timestamp: Date.now(),
                source: 'daily-message',
                suppressNotification: false,
                originMessage: message
              }
            }));
            
            // Tamb√©m ativar diretamente o campo via componente
            window.dispatchEvent(new CustomEvent('activate-constellation', {
              detail: {
                sessionId,
                timestamp: Date.now(),
                source: 'daily-message',
                suppressNotification: false
              }
            }));
            
            // Notificar o usu√°rio via toast
            if (!message.suppressNotification) {
              toast.info('Campo de Constela√ß√£o ativado por outro participante', {
                position: "top-right",
                autoClose: 3000
              });
            }
          } else if (message && message.type === 'constellation-update') {
            // Processar atualiza√ß√µes de posi√ß√£o/rota√ß√£o dos representantes
            console.log('Recebida atualiza√ß√£o de posi√ß√£o/estado para o campo:', message);
            
            // Disparar evento para componentes que precisam processar esta atualiza√ß√£o
            window.dispatchEvent(new CustomEvent('constellation-field-update', {
              detail: {
                ...message,
                timestamp: Date.now(),
                source: 'daily-message'
              }
            }));
          } else if (message && message.type === 'client-joined') {
            // Novo cliente entrou na sala
            console.log('Novo cliente entrou na sala:', message.clientId);
            
            // Se este cliente j√° tem o campo ativo, notificar o novo participante
            if (showConstellation) {
              console.log('Notificando novo participante que o campo j√° est√° ativo...');
              
              setTimeout(() => {
                try {
                  dailyCallObj.sendAppMessage({
                    type: 'constellation-show',
                    show: true,
                    sessionId,
                    timestamp: Date.now(),
                    clientId,
                    forceUpdate: true,
                    source: 'existing-client'
                  }, '*');
                  
                  console.log('Notifica√ß√£o enviada para o novo participante');
                } catch (error) {
                  console.error('Erro ao notificar novo participante:', error);
                }
              }, 2000); // Atraso para garantir que o cliente esteja pronto
            }
          }
        });
        
        console.log('‚úÖ Listener para mensagens Daily.co configurado com sucesso');
        
        // Enviar mensagem inicial para notificar presen√ßa ap√≥s um breve delay
        // para garantir que a conex√£o est√° est√°vel
        setTimeout(() => {
          try {
            console.log('Enviando mensagem inicial de presen√ßa...');
            
            dailyCallObj.sendAppMessage({
              type: 'client-joined',
              sessionId,
              timestamp: Date.now(),
              clientId
            }, '*');
            
            console.log('Mensagem de presen√ßa enviada com sucesso');
            
            // Se o campo j√° estiver ativo, enviar estado para sincronizar
            if (showConstellation) {
              console.log('Campo j√° ativo neste cliente, notificando outros participantes...');
              
              dailyCallObj.sendAppMessage({
                type: 'constellation-show',
                show: true,
                sessionId,
                timestamp: Date.now(),
                clientId,
                forceUpdate: true
              }, '*');
              
              console.log('Mensagem de sincroniza√ß√£o enviada com sucesso');
            }
          } catch (error) {
            console.error('Erro ao enviar mensagem inicial:', error);
          }
        }, 1500);
    } catch (err) {
      console.error('‚ùå Erro ao configurar listener para app-messages:', err);
    }
  }, [sessionId, showConstellation]);

  // Armazenar a fun√ß√£o no ref para evitar problemas de depend√™ncia circular
  useEffect(() => {
    setupDailyMessageHandlersRef.current = setupDailyMessageHandlers;
  }, [setupDailyMessageHandlers]);

  // Modificar a fun√ß√£o handleDailyReference para aguardar o estado correto da conex√£o antes de iniciar sincroniza√ß√£o
  const handleDailyReference = useCallback((dailyCallObj) => {
    if (dailyCallObj) {
      console.log('üîÑ Recebida refer√™ncia do Daily.co API object');
      
      // Armazenar a refer√™ncia no ref global para acesso em outros lugares
      dailyCallRef.current = dailyCallObj;
      
      // Informa√ß√µes desta inst√¢ncia
      const CLIENT_ID = `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      console.log(`ID deste cliente: ${CLIENT_ID}`);
      
      // Verificar se o objeto API tem os m√©todos esperados
      if (typeof dailyCallObj.on !== 'function' || typeof dailyCallObj.sendAppMessage !== 'function') {
        console.error('Objeto Daily.co n√£o tem os m√©todos esperados:', { 
          hasOn: typeof dailyCallObj.on === 'function',
          hasSendAppMessage: typeof dailyCallObj.sendAppMessage === 'function'
        });
        return;
      }
      
      // NOVA VERIFICA√á√ÉO: Verificar o estado atual da conex√£o
      const meetingState = dailyCallObj.meetingState();
      console.log('Estado atual da conex√£o Daily.co:', meetingState);
      
      // Configurar um listener para aguardar conex√£o completa se ainda n√£o estiver
      if (meetingState !== 'joined-meeting') {
        console.log('Aguardando conex√£o completa antes de configurar sincroniza√ß√£o...');
        
        const handleMeetingJoined = () => {
          console.log('üü¢ Participante conectado √† sala - iniciando sincroniza√ß√£o');
          
          // Usar a fun√ß√£o via ref para evitar problemas de depend√™ncia circular
          if (setupDailyMessageHandlersRef.current) {
            setupDailyMessageHandlersRef.current(dailyCallObj, CLIENT_ID);
          } else {
            console.error('setupDailyMessageHandlers n√£o est√° dispon√≠vel!');
          }
          
          // Remover este listener ap√≥s uso
          dailyCallObj.off('joined-meeting', handleMeetingJoined);
        };
        
        // Configurar listener para estado de conex√£o
        dailyCallObj.on('joined-meeting', handleMeetingJoined);
      } else {
        // J√° est√° conectado, configurar imediatamente
        console.log('üü¢ Conex√£o j√° estabelecida - iniciando sincroniza√ß√£o imediatamente');
        
        // Usar a fun√ß√£o via ref para evitar problemas de depend√™ncia circular
        if (setupDailyMessageHandlersRef.current) {
          setupDailyMessageHandlersRef.current(dailyCallObj, CLIENT_ID);
        } else {
          console.error('setupDailyMessageHandlers n√£o est√° dispon√≠vel!');
        }
      }
    } else {
      console.warn('Recebida refer√™ncia nula do Daily.co API object');
    }
  }, [sessionId]);

  // Montar o componente apenas uma vez
  useEffect(() => {
    if (session && !isRoomMounted) {
      // Delay para garantir estabilidade antes de montar o componente
      const timer = setTimeout(() => {
        setIsRoomMounted(true);
      }, 500);
      
      return () => clearTimeout(timer);
    }
  }, [session, isRoomMounted]);

  // Toggle fullscreen for constellation field
  const toggleFullScreen = () => {
    if (!constellationContainerRef.current) return;
    
    if (!isFullScreen) {
      if (constellationContainerRef.current.requestFullscreen) {
        constellationContainerRef.current.requestFullscreen();
      } else if (constellationContainerRef.current.webkitRequestFullscreen) {
        constellationContainerRef.current.webkitRequestFullscreen();
      } else if (constellationContainerRef.current.msRequestFullscreen) {
        constellationContainerRef.current.msRequestFullscreen();
      }
      setIsFullScreen(true);
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
      setIsFullScreen(false);
    }
  };

  // Adicionar efeito para garantir visibilidade do campo e do v√≠deo quando ativo
  useEffect(() => {
    if (showConstellation) {
      // Fun√ß√£o para garantir visibilidade
      const ensureVisibility = () => {
        // Garantir que o campo de constela√ß√£o seja vis√≠vel
        const constellationContainer = document.querySelector('.constellation-container');
        if (constellationContainer) {
          constellationContainer.style.display = 'block';
          constellationContainer.style.visibility = 'visible';
          constellationContainer.style.opacity = '1';
          constellationContainer.style.zIndex = '1';
        }
        
        // Garantir que o v√≠deo em PIP esteja vis√≠vel
        const videoContainer = document.querySelector('.video-container-pip');
        if (videoContainer) {
          videoContainer.style.display = 'block';
          videoContainer.style.visibility = 'visible';
          videoContainer.style.zIndex = '9999';
          videoContainer.style.position = 'fixed';
          videoContainer.style.right = '20px';
          videoContainer.style.top = '20px';
          videoContainer.style.width = '300px';
          videoContainer.style.height = '200px';
        }
        
        // Garantir que o container principal tenha a classe correta
        const sessionRoom = document.querySelector('.session-room');
        if (sessionRoom && !sessionRoom.classList.contains('with-constellation')) {
          sessionRoom.classList.add('with-constellation');
        }
      };
      
      // Chamar imediatamente
      ensureVisibility();
      
      // E tamb√©m depois de um curto delay para garantir ap√≥s renderiza√ß√£o
      const timer1 = setTimeout(ensureVisibility, 500);
      const timer2 = setTimeout(ensureVisibility, 1000);
      
      // Configurar um intervalo para verificar periodicamente
      const interval = setInterval(ensureVisibility, 2000);
      
      return () => {
        clearTimeout(timer1);
        clearTimeout(timer2);
        clearInterval(interval);
      };
    }
  }, [showConstellation]);

  // Sair da sess√£o
  const exitSession = async () => {
    try {
      // Atualizar status da sess√£o para conclu√≠da
      if (session && session.status === 'em_andamento') {
        await markSessionCompleted(sessionId);
      }
      navigate('/dashboard');
    } catch (error) {
      console.error('Erro ao sair da sess√£o:', error);
      toast.error('Erro ao finalizar a sess√£o');
      navigate('/dashboard');
    }
  };

  // Verificar se a sess√£o √© virtual/emerg√™ncia e adaptar a experi√™ncia
  const isVirtualSession = session?.isVirtual || session?.isEmergency || false;
  
  useEffect(() => {
    if (isVirtualSession) {
      // Log para depura√ß√£o
      console.log('Sess√£o virtual detectada:', session);
      
      // Podemos configurar comportamentos espec√≠ficos para sess√£o virtual
      toast.info('Voc√™ est√° em uma sala de sess√£o tempor√°ria. Algumas funcionalidades podem ser limitadas.');
      
      // Podemos simular carregamento mais r√°pido
      if (loading) {
        setLoading(false);
      }
    }
  }, [isVirtualSession, session, loading]);
  
  // Componente de sess√£o virtual para quando n√£o temos dados reais
  const VirtualSessionFallback = () => {
    return (
      <div className="virtual-session-container">
        <div className="virtual-video-container">
          <div className="virtual-video-placeholder">
            <div className="virtual-video-message">
              <h3>Sala de Sess√£o Tempor√°ria</h3>
              <p>Esta √© uma sala de sess√£o tempor√°ria onde voc√™ pode se conectar com o terapeuta.</p>
              <p>Em caso de problemas t√©cnicos, entre em contato por outros meios.</p>
            </div>
          </div>
        </div>
      </div>
    );
  };

  // Adicionar listener para o evento que ocorre antes de ativar o campo
  useEffect(() => {
    const handlePreConstellationChange = () => {
      console.log('Evento pre-constellation-change detectado, evitando mudan√ßa de modo de v√≠deo');
      // Marcar para n√£o mudar o modo de v√≠deo quando o estado de showConstellation mudar
      videoModeRef.current.skipNextChange = true;
    };
    
    document.addEventListener('pre-constellation-change', handlePreConstellationChange);
    
    return () => {
      document.removeEventListener('pre-constellation-change', handlePreConstellationChange);
    };
  }, []);

  // Memoizar o componente FallbackMeeting para evitar recria√ß√£o
  const MemoizedFallbackMeeting = useMemo(() => {
    console.log('Criando inst√¢ncia memorizada do FallbackMeeting para sessionId:', sessionId);
    
    if (!sessionId) return null;
    
    // Remover TODAS as depend√™ncias que possam mudar durante a vida do componente
    // Criar uma inst√¢ncia totalmente est√°vel que ser√° controlada apenas via ref
    
    return (
      <FallbackMeeting
        roomName={sessionId}
        userName={session?.therapist?.name || session?.client?.name || 'Usu√°rio'}
        floating={false} // Valor inicial que ser√° atualizado via ref
        onPipModeChange={handlePipModeChange}
        onDailyReference={handleDailyReference}
        // Chave FIXA para garantir que o componente NUNCA seja remontado
        key="meeting-stable-instance"
        ref={fallbackMeetingRef}
      />
    );
  // Remover TODAS as depend√™ncias para evitar recria√ß√£o em qualquer circunst√¢ncia
  }, []);

  // Modificador para for√ßar uso da mesma inst√¢ncia do componente de v√≠deo
  useEffect(() => {
    // Atualizar manual da prop floating quando showConstellation mudar
    if (fallbackMeetingRef.current && fallbackMeetingRef.current.setFloating) {
      console.log(`Atualizando manualmente a prop floating para: ${showConstellation}`);
      fallbackMeetingRef.current.setFloating(showConstellation);
    }
  }, [showConstellation]);
  
  // Chamada no useEffect principal do componente
  useEffect(() => {
    // Configurar sistema de debug para monitoramento de componentes
    const cleanupDebug = setupDebugMonitoring();
    
    // Limpar ao desmontar
    return () => {
      cleanupDebug();
    };
  }, []);

  if (loading) {
    return <div className="loading-container">Carregando sess√£o...</div>;
  }

  // Mesmo com erro, tentar renderizar o componente de videochamada
  return (
    <AIProvider>
      <div 
        className={`session-room ${isFullScreen ? 'fullscreen' : ''} ${showConstellation ? 'with-constellation' : ''}`}
        data-session-id={sessionId}
      >
        {isVirtualSession ? (
          <VirtualSessionFallback />
        ) : (
          <>
            {/* Layout principal - videoconfer√™ncia ou constela√ß√£o */}
            {!showConstellation ? (
              <div className="session-video-container">
                {sessionId && isRoomMounted && MemoizedFallbackMeeting}
              </div>
            ) : (
              <div 
                ref={constellationContainerRef}
                className={`constellation-container ${isFullScreen ? 'fullscreen' : ''}`}
              >
                {/* Informa√ß√£o de carregamento do campo */}
                <div className="constellation-loading-info" style={{ 
                  position: 'absolute', 
                  top: '50%', 
                  left: '50%', 
                  transform: 'translate(-50%, -50%)',
                  zIndex: 1,
                  background: 'rgba(0,0,0,0.7)',
                  color: 'white',
                  padding: '10px 20px',
                  borderRadius: '5px',
                  display: loading ? 'block' : 'none'
                }}>
                  Carregando Campo de Constela√ß√£o...
                </div>
                
                <ConstellationField3D 
                  isHost={userRole === 'therapist-provider'}
                  sessionId={sessionId}
                  key={`constellation-${sessionId}`}
                  modalMode={isFullScreen}
                  isActive={true}
                  debug={true}
                />

                {(() => {
                  // C√≥digo para executar imediatamente para debug
                  console.log('Estrutura DOM na renderiza√ß√£o:', {
                    hasConstellationContainer: !!document.querySelector('.constellation-container'),
                    hasField3DContainer: !!document.querySelector('.constellation-field-3d-container'),
                    sessionRoomClass: document.querySelector('.session-room')?.className || 'n√£o encontrado',
                    constellationContainerDisplay: window.getComputedStyle(
                      document.querySelector('.constellation-container') || document.createElement('div')
                    ).display,
                    constellationContainerVisibility: window.getComputedStyle(
                      document.querySelector('.constellation-container') || document.createElement('div')
                    ).visibility
                  });
                  return null; // N√£o renderiza nada
                })()}
                
                {/* Bot√£o de fullscreen */}
                <button
                  className="fullscreen-btn"
                  onClick={toggleFullScreen}
                  title={isFullScreen ? "Sair da tela cheia" : "Entrar em tela cheia"}
                  style={{
                    position: 'absolute',
                    bottom: '20px',
                    right: '20px',
                    width: '40px',
                    height: '40px',
                    backgroundColor: 'rgba(0, 0, 0, 0.6)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    zIndex: 10,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: '20px'
                  }}
                >
                  {isFullScreen ? '‚§ì' : '‚§¢'}
                </button>
                
                {/* V√≠deo em modo PIP quando o campo de constela√ß√£o est√° ativo */}
                <div 
                  ref={videoContainerRef}
                  className={`video-container-pip ${isDragging ? 'dragging' : ''} ${isResizing ? 'resizing' : ''}`}
                  style={{
                    transform: `translate(${videoPosition.x}px, ${videoPosition.y}px)`,
                    width: `${videoDimensions.width}px`,
                    height: `${videoDimensions.height}px`,
                    zIndex: 9999
                  }}
                  onMouseDown={handleMouseDown}
                >
                  {sessionId && isRoomMounted && MemoizedFallbackMeeting}
                  
                  {/* Bot√£o para sair do modo constela√ß√£o */}
                  <button 
                    className="exit-constellation-btn"
                    onClick={handleConstellationToggle}
                    title="Sair do Campo de Constela√ß√£o"
                  >
                    ‚úï
                  </button>
                  
                  {/* Elemento para redimensionar o v√≠deo */}
                  <div 
                    className="video-resizer video-resizer-br"
                    onMouseDown={handleResizeStart}
                  ></div>
                </div>
              </div>
            )}
          </>
        )}
        
        {/* Ferramentas de IA - for√ßar exibi√ß√£o para o terapeuta */}
        {(userRole === 'therapist-provider' || !userRole) && (
          <div id="direct-ai-buttons" className="ai-toolbar-bottom" ref={aiContainerRef}>
            <AIToolsContainer onConstellationClick={handleConstellationToggle} />
          </div>
        )}
      </div>
    </AIProvider>
  );
};

export default SessionRoom;